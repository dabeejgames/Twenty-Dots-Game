<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#0f0f1e">
    <title>Twenty Dots - Multiplayer</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html {
            height: 100%;
            height: -webkit-fill-available;
        }
        
        body {
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            touch-action: manipulation;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        /* Random background themes with BOLD visible patterns */
        body.bg-default { 
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #2a1a3e 100%); 
        }
        body.bg-stars { 
            background: 
                radial-gradient(3px 3px at 20px 30px, #fff, transparent),
                radial-gradient(3px 3px at 40px 70px, #ddd, transparent),
                radial-gradient(2px 2px at 90px 40px, #fff, transparent),
                radial-gradient(3px 3px at 130px 80px, #ccc, transparent),
                radial-gradient(2px 2px at 160px 120px, #fff, transparent),
                radial-gradient(4px 4px at 200px 50px, #eee, transparent),
                radial-gradient(2px 2px at 250px 160px, #fff, transparent),
                radial-gradient(3px 3px at 300px 100px, #ddd, transparent),
                radial-gradient(2px 2px at 350px 180px, #fff, transparent),
                radial-gradient(4px 4px at 400px 60px, #eee, transparent),
                radial-gradient(3px 3px at 80px 150px, #fff, transparent),
                radial-gradient(2px 2px at 180px 30px, #ccc, transparent),
                radial-gradient(3px 3px at 280px 170px, #fff, transparent),
                radial-gradient(2px 2px at 380px 120px, #ddd, transparent),
                radial-gradient(4px 4px at 50px 100px, #fff, transparent),
                linear-gradient(135deg, #05051a 0%, #0a0a2e 50%, #050520 100%);
            background-size: 450px 200px;
        }
        body.bg-grid { 
            background: 
                linear-gradient(rgba(0,255,255,0.15) 2px, transparent 2px),
                linear-gradient(90deg, rgba(0,255,255,0.15) 2px, transparent 2px),
                linear-gradient(135deg, #051520 0%, #0a2535 50%, #051525 100%);
            background-size: 60px 60px, 60px 60px, 100% 100%;
        }
        body.bg-hexagon { 
            background: 
                repeating-linear-gradient(60deg, rgba(0,255,100,0.08), rgba(0,255,100,0.08) 1px, transparent 1px, transparent 30px),
                repeating-linear-gradient(-60deg, rgba(0,255,100,0.08), rgba(0,255,100,0.08) 1px, transparent 1px, transparent 30px),
                repeating-linear-gradient(0deg, rgba(0,255,100,0.06), rgba(0,255,100,0.06) 1px, transparent 1px, transparent 52px),
                linear-gradient(135deg, #051a05 0%, #0a2e10 50%, #051a08 100%);
        }
        body.bg-circuit { 
            background: 
                repeating-linear-gradient(90deg, transparent, transparent 48px, rgba(255,0,255,0.2) 48px, rgba(255,0,255,0.2) 52px),
                repeating-linear-gradient(0deg, transparent, transparent 48px, rgba(255,0,255,0.2) 48px, rgba(255,0,255,0.2) 52px),
                radial-gradient(circle at 50px 50px, rgba(255,100,255,0.4) 4px, transparent 4px),
                linear-gradient(135deg, #1a051a 0%, #2e0a2e 50%, #1a0520 100%);
            background-size: 100px 100px;
        }
        body.bg-dots { 
            background: 
                radial-gradient(circle, rgba(255,150,50,0.4) 8px, transparent 8px),
                linear-gradient(135deg, #1a0a05 0%, #301508 50%, #1a0a05 100%);
            background-size: 50px 50px, 100% 100%;
        }
        body.bg-waves { 
            background: 
                repeating-linear-gradient(45deg, transparent, transparent 20px, rgba(100,150,255,0.1) 20px, rgba(100,150,255,0.1) 40px),
                repeating-linear-gradient(-45deg, transparent, transparent 20px, rgba(150,100,255,0.1) 20px, rgba(150,100,255,0.1) 40px),
                linear-gradient(135deg, #05051a 0%, #0a1040 50%, #05052a 100%);
        }
        body.bg-triangles { 
            background: 
                linear-gradient(60deg, transparent 64%, rgba(0,255,200,0.15) 64%, rgba(0,255,200,0.15) 66%, transparent 66%),
                linear-gradient(-60deg, transparent 64%, rgba(0,255,200,0.15) 64%, rgba(0,255,200,0.15) 66%, transparent 66%),
                linear-gradient(135deg, #051a18 0%, #0a3530 50%, #052a28 100%);
            background-size: 80px 140px, 80px 140px, 100% 100%;
        }
        body.bg-plasma { 
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(150,0,255,0.4) 0%, transparent 35%),
                radial-gradient(ellipse at 80% 80%, rgba(255,0,150,0.4) 0%, transparent 35%),
                radial-gradient(ellipse at 60% 30%, rgba(0,150,255,0.3) 0%, transparent 40%),
                radial-gradient(ellipse at 30% 70%, rgba(255,150,0,0.3) 0%, transparent 40%),
                linear-gradient(135deg, #0a051a 0%, #150a25 50%, #0a0520 100%);
        }
        body.bg-diamond { 
            background: 
                repeating-linear-gradient(45deg, transparent, transparent 28px, rgba(255,255,255,0.08) 28px, rgba(255,255,255,0.08) 32px),
                repeating-linear-gradient(-45deg, transparent, transparent 28px, rgba(255,255,255,0.08) 28px, rgba(255,255,255,0.08) 32px),
                linear-gradient(135deg, #1a0515 0%, #2a0a25 50%, #1a0518 100%);
        }
        
        .main-container { display: none; width: 100vw; height: 100vh; }
        .main-container.active { display: flex; }
        
        /* Header */
        .header {
            text-align: center;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-bottom: 2px solid #ffd700;
            position: relative;
        }
        
        .header h1 { color: #ffd700; font-size: 2em; }
        .turn-info { font-size: 1.5em; color: #ff6b6b; margin: 10px 0; }
        
        /* Music Controls Container */
        .music-controls {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 8px;
        }
        
        /* Music Toggle Button */
        .music-toggle {
            background: rgba(255,215,0,0.2);
            border: 2px solid #ffd700;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .music-toggle:hover {
            background: rgba(255,215,0,0.4);
            box-shadow: 0 0 15px rgba(255,215,0,0.5);
        }
        
        .music-toggle.playing {
            background: rgba(76,175,80,0.3);
            border-color: #4CAF50;
            animation: pulse-music 2s infinite;
        }
        
        .skip-btn {
            font-size: 1.1em;
        }
        
        @keyframes pulse-music {
            0%, 100% { box-shadow: 0 0 5px rgba(76,175,80,0.5); }
            50% { box-shadow: 0 0 20px rgba(76,175,80,0.8); }
        }
        
        /* Game container */
        .game-container {
            display: flex;
            gap: 15px;
            padding: 15px;
            flex: 1;
            overflow: auto;
            min-height: 0;
        }
        
        /* Left panel - Logo and Players */
        .left-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 300px;
            flex-shrink: 0;
            gap: 15px;
        }
        
        .logo-box {
            background: #1a1a2e;
            border: 3px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-height: 180px;
        }
        
        .logo-box img {
            max-width: 100%;
            max-height: 150px;
            object-fit: contain;
        }
        
        /* Players 2x2 grid in left panel */
        .players-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 100%;
        }
        
        /* Center panel - Landmines and Board */
        .center-panel {
            display: flex;
            flex-direction: column;
            flex: 1;
            gap: 15px;
            position: relative;
            min-height: 0;
            overflow: auto;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        /* Players row - hidden on desktop, shown on mobile */
        .players-top {
            display: none;
            gap: 15px;
            justify-content: center;
            height: auto;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        /* Bottom players row - no longer used */
        .players-bottom { display: none; }
        
        .player-box {
            background: #1a1a2e;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            text-align: center;
            font-size: 0.9em;
            overflow: hidden;
        }
        
        .player-box.active { border-color: #4CAF50; background: rgba(76, 175, 80, 0.1); }
        .player-box.me { border-color: #ffd700; }
        
        .player-name { color: #ffd700; font-weight: bold; font-size: 0.95em; }
        .player-score { color: #4CAF50; font-size: 1.2em; font-weight: bold; margin: 5px 0; }
        .player-score-dots { display: flex; justify-content: center; gap: 3px; margin: 5px 0; flex-wrap: wrap; }
        .score-dot { width: 16px; height: 16px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.7em; font-weight: bold; }
        .player-hand { font-size: 0.85em; color: #aaa; }
        .player-discard { font-size: 0.8em; color: #aaa; margin-top: 8px; }
        /* Fixed height discard area with visible border */
        .discard-cards { display: flex; justify-content: center; gap: 6px; margin-top: 5px; flex-wrap: wrap; height: 55px; padding: 5px; overflow: hidden; border: 2px solid #555; border-radius: 6px; background: rgba(0,0,0,0.2); }
        .discard-card { width: 50px; height: 42px; border-radius: 4px; font-size: 0.65em; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; }
        
        /* Board */
        .board-section {
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
            margin-top: 0;
        }
        
        .board {
            display: -ms-grid;
            display: grid;
            -ms-grid-columns: 35px 4px 70px 4px 70px 4px 70px 4px 70px 4px 70px 4px 70px 4px 35px;
            -ms-grid-rows: 35px 4px 70px 4px 70px 4px 70px 4px 70px 4px 70px 4px 70px 4px 35px;
            grid-template-columns: 35px 70px 70px 70px 70px 70px 70px 35px;
            grid-template-rows: 35px 70px 70px 70px 70px 70px 70px 35px;
            gap: 4px;
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 10px;
            width: fit-content;
            width: -moz-fit-content;
        }
        
        .board-label { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: #ffd700; 
            font-weight: bold; 
            font-size: 1.3em; 
            font-family: 'Segoe UI', 'Arial Black', sans-serif;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .cell {
            background: rgba(50,50,70,0.8);
            border: 2px solid white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .cell:hover { background: rgba(60,60,80,0.9); }
        
        .cell.swap-selected {
            background: rgba(255, 215, 0, 0.5);
            border: 3px solid gold;
            animation: swap-pulse 0.5s infinite alternate;
        }
        
        @keyframes swap-pulse {
            from { box-shadow: 0 0 5px gold; }
            to { box-shadow: 0 0 15px gold; }
        }
        
        /* Blocked cell styling */
        .cell.blocked {
            background: rgba(255, 68, 68, 0.2);
            border: 2px dashed #ff4444;
        }
        
        .block-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.8em;
            opacity: 0.8;
            z-index: 5;
        }
        
        /* Landmine section with label */
        .landmines-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 520px;
        }
        
        .landmines-label {
            color: #ff6666;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        /* Landmine display area - FIXED height to prevent layout shift */
        .landmines-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            width: 100%;
            height: 80px;  /* Fixed height */
            padding: 5px 10px;
            background: rgba(50, 0, 0, 0.3);
            border-radius: 8px;
            border: 2px dashed #ff3333;
            overflow: hidden;
        }
        
        .landmine-card {
            width: 55px;
            height: 65px;
            background: linear-gradient(135deg, #3a0a0a, #1a0505);
            border: 2px solid #ff3333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
            color: #ff6666;
            box-shadow: 0 0 10px rgba(255,0,0,0.5);
            animation: landmine-pulse 1.5s infinite alternate;
        }
        
        .landmine-card .landmine-icon {
            font-size: 1.8em;
        }
        
        .landmine-card .landmine-label {
            font-size: 0.65em;
            color: #ff9999;
            margin-top: 2px;
            font-weight: bold;
        }
        
        @keyframes landmine-pulse {
            from { box-shadow: 0 0 5px rgba(255,0,0,0.3); }
            to { box-shadow: 0 0 15px rgba(255,0,0,0.6); }
        }
        
        .dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .dot.red { background: linear-gradient(135deg, #FF4757 0%, #e74c3c 100%); }
        .dot.blue { background: linear-gradient(135deg, #36A2EB 0%, #2980b9 100%); }
        .dot.purple { background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%); }
        .dot.green { background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%); }
        .dot.yellow { background: radial-gradient(circle, #FFEB3B, #FFD700); box-shadow: 0 0 20px rgba(255,215,0,0.8); border: 2px dashed rgba(255,215,0,0.8); }
        
        /* Right panel - Hand and Controls */
        .right-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(26, 26, 46, 0.9);
            border: 3px solid #6c5ce7;
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .hand-title { color: #ffd700; font-weight: bold; font-size: 1.1em; margin-bottom: 10px; }
        
        .cards-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        
        .card {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border: 3px solid transparent;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            min-height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-size: 1.1em;
        }
        
        .card.red { background: linear-gradient(135deg, #FF4757 0%, #e74c3c 100%); }
        .card.blue { background: linear-gradient(135deg, #36A2EB 0%, #2980b9 100%); }
        .card.purple { background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%); }
        .card.green { background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%); }
        
        .card.selected { border-color: #FFD700; box-shadow: 0 0 20px rgba(255,215,0,0.6); }
        
        .card-location { font-size: 1.2em; }
        .card-color { font-size: 0.8em; opacity: 0.8; }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
        }
        
        .btn-play { background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%); }
        .btn-play:hover:not(:disabled) { box-shadow: 0 6px 20px rgba(76,175,80,0.6); }
        
        .btn-end { background: linear-gradient(135deg, #ff6b6b 0%, #ff5252 100%); }
        .btn-end:hover:not(:disabled) { box-shadow: 0 6px 20px rgba(255,107,107,0.6); }
        
        .btn-roll { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); }
        .btn-roll:hover:not(:disabled) { box-shadow: 0 6px 20px rgba(243,156,18,0.6); }
        
        .btn-clear { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); }
        .btn-clear:hover:not(:disabled) { box-shadow: 0 6px 15px rgba(231,76,60,0.6); }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Mode screen */
        #modeScreen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        
        .mode-selection {
            text-align: center;
        }
        
        .mode-buttons {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin: 40px 0;
        }
        
        .mode-button {
            background: #1a1a2e;
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s;
            width: 200px;
        }
        
        .mode-button:hover {
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
            transform: scale(1.05);
        }
        
        .mode-icon { font-size: 60px; margin-bottom: 15px; }
        .mode-title { color: #ffd700; font-size: 1.5em; font-weight: bold; margin-bottom: 10px; }
        .mode-description { color: #aaa; font-size: 0.9em; }
        
        /* Join screen */
        #joinScreen {
            display: none;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        
        .join-form {
            background: #1a1a2e;
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 40px;
            width: 400px;
        }
        
        .form-group {
            margin: 20px 0;
        }
        
        .form-group label {
            display: block;
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #6c5ce7;
            border-radius: 6px;
            background: rgba(108,92,231,0.1);
            color: white;
            font-size: 1em;
        }
        
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #6c5ce7;
            border-radius: 6px;
            background: rgba(108,92,231,0.1);
            color: white;
            font-size: 1em;
        }
        
        .form-group select option {
            background: #2a2a3e;
            color: white;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255,215,0,0.3);
        }
        
        .btn-join {
            width: 100%;
            background: linear-gradient(135deg, #ffd700 0%, #f39c12 100%);
            color: #000;
            font-weight: bold;
        }
        
        .btn-join:hover:not(:disabled) {
            box-shadow: 0 0 20px rgba(255,215,0,0.6);
        }
        
        .error-message {
            color: #FF4757;
            margin-top: 15px;
            text-align: center;
            display: none;
        }
        
        .error-message.show { display: block; }
        
        /* Mobile Responsive Design - Clean unified approach */
        @media (max-width: 1200px) {
            .board {
                grid-template-columns: 30px repeat(6, 55px) 30px;
                grid-template-rows: 30px repeat(6, 55px) 30px;
                gap: 2px;
                padding: 10px;
            }
            
            .dot { width: 28px; height: 28px; font-size: 9px; }
            .left-panel { width: 260px; }
            .right-panel { width: 220px; }
        }
        
        /* Tablet and Mobile: Vertical stacked layout */
        @media (max-width: 992px) {
            .main-container {
                flex-direction: column;
                height: 100vh;
                height: calc(var(--vh, 1vh) * 100);
                overflow: hidden;
            }
            
            .header {
                padding: 8px 10px;
                min-height: auto;
                flex-shrink: 0;
            }
            
            .header h1 { font-size: 1em; }
            .turn-info { font-size: 0.9em; margin: 3px 0; }
            
            .game-container {
                flex-direction: column;
                gap: 8px;
                padding: 8px;
                flex: 1;
                overflow: hidden;
            }
            
            /* Hide left panel logo on mobile - show in header instead */
            .left-panel { display: none; }
            
            /* Hide players grid on mobile (it's in left panel) */
            .players-grid { display: none; }
            
            .center-panel {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 5px;
                min-height: 0;
                overflow: hidden;
                justify-content: flex-start;
                padding-top: 5px;
            }
            
            /* Players row - all 4 in a single horizontal row */
            .players-top {
                display: flex;
                gap: 4px;
                height: auto;
                margin: 0 4px;
                padding: 0 2px;
                position: relative;
                top: auto;
                left: auto;
                right: auto;
                flex-shrink: 0;
                flex-wrap: nowrap;
                order: 1;
            }
            
            .players-bottom { display: none; }
            
            .player-box {
                flex: 1;
                min-width: 0;
                max-width: 25%;
                width: auto;
                padding: 3px 2px;
                font-size: 0.6em;
                overflow: visible;
            }
            
            .player-name { font-size: 0.7em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
            .player-score { font-size: 0.8em; margin: 1px 0; }
            .player-score-dots { gap: 1px; margin: 1px 0; flex-wrap: wrap; justify-content: center; max-width: 100%; }
            .score-dot { width: 8px; height: 8px; font-size: 0.4em; }
            .player-hand { display: none; }
            .player-discard { font-size: 0.4em; margin-top: 1px; }
            .discard-cards { gap: 2px !important; height: auto !important; min-height: 16px !important; max-height: 32px !important; padding: 2px !important; justify-content: center !important; border: 1px solid #555 !important; border-radius: 3px !important; background: rgba(0,0,0,0.3) !important; overflow: visible !important; flex-wrap: wrap !important; margin-top: 2px !important; }
            .discard-card { width: 10px !important; height: 10px !important; font-size: 0 !important; border-radius: 2px !important; flex-shrink: 0 !important; }
            
            /* Board section - centered and takes remaining space */
            .board-section {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 0;
                margin: 0;
                order: 2;
            }
            
            .board {
                grid-template-columns: 18px repeat(6, 42px) 18px;
                grid-template-rows: 18px repeat(6, 42px) 18px;
                width: auto;
                height: auto;
                aspect-ratio: unset;
                gap: 3px;
                padding: 8px;
            }
            
            .cell { min-width: 40px; min-height: 40px; }
            .dot { width: 24px; height: 24px; font-size: 8px; }
            .board-label { font-size: 0.75em; }
            
            /* Hand and controls at bottom */
            .right-panel {
                width: 100%;
                height: auto;
                flex-direction: column;
                gap: 4px;
                padding: 6px 8px;
                border-radius: 12px 12px 0 0;
                border: 2px solid #6c5ce7;
                border-bottom: none;
                flex-shrink: 0;
                max-height: 160px;
            }
            
            .hand-title { font-size: 0.8em; margin-bottom: 2px; }
            
            .cards-container {
                flex-direction: row;
                overflow-x: auto;
                overflow-y: hidden;
                gap: 6px;
                margin-bottom: 3px;
                padding: 3px 2px;
                min-height: 55px;
                max-height: 60px;
                flex-shrink: 0;
                -webkit-overflow-scrolling: touch;
            }
            
            .card {
                min-width: 55px;
                min-height: 50px;
                padding: 4px;
                font-size: 0.7em;
                flex-shrink: 0;
            }
            
            .controls {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 6px;
            }
            
            .controls button {
                flex: 1 1 30%;
                min-height: 40px;
                padding: 8px 6px;
                font-size: 0.75em;
            }
            
            .landmines-section {
                width: 100%;
                max-width: none;
                flex-shrink: 0;
                order: 3;
                margin-top: auto;
                padding-bottom: 5px;
            }
            
            .landmines-label {
                font-size: 0.7em;
                margin-bottom: 2px;
            }
            
            .landmines-display {
                display: flex;
                flex-direction: row;
                flex-wrap: nowrap;
                gap: 5px;
                padding: 4px 8px;
                margin: 0;
                min-width: auto;
                min-height: 35px;
                height: auto;
                max-height: 50px;
                overflow-x: auto;
                overflow-y: hidden;
                justify-content: center;
            }
            
            .landmine-card {
                width: 30px;
                height: 35px;
                font-size: 0.6em;
                flex-shrink: 0;
            }
            
            .landmine-card .landmine-icon { font-size: 1.3em; }
            .landmine-card .landmine-label { font-size: 0.55em; }
        }
        
        /* Phone screens */
        @media (max-width: 600px) {
            .header {
                padding: 6px 8px;
            }
            
            .header h1 { font-size: 0.85em; }
            .turn-info { font-size: 0.75em; }
            
            .music-controls {
                right: 8px;
                gap: 4px;
            }
            
            .music-toggle {
                width: 32px;
                height: 32px;
                font-size: 0.9em;
            }
            
            .skip-btn {
                font-size: 0.8em;
            }
            
            .game-container {
                gap: 4px;
                padding: 4px;
            }
            
            .players-top { 
                gap: 3px;
                flex-wrap: nowrap;
                margin: 0 3px;
            }
            
            .player-box {
                padding: 2px 1px;
                font-size: 0.5em;
                border-radius: 4px;
                max-width: 25%;
            }
            
            .player-name { font-size: 0.65em; }
            .player-score { font-size: 0.75em; margin: 1px 0; }
            .player-score-dots { gap: 1px; margin: 1px 0; flex-wrap: wrap; }
            .score-dot { width: 7px; height: 7px; font-size: 0.35em; }
            .player-hand { display: none; }
            .player-discard { font-size: 0.35em; margin-top: 1px; }
            .discard-cards { height: auto !important; min-height: 14px !important; max-height: 28px !important; gap: 2px !important; padding: 2px !important; border: 1px solid #555 !important; border-radius: 2px !important; background: rgba(0,0,0,0.3) !important; overflow: visible !important; flex-wrap: wrap !important; }
            .discard-card { width: 8px !important; height: 8px !important; font-size: 0 !important; border-radius: 2px !important; }
            
            .board {
                grid-template-columns: 15px repeat(6, 38px) 15px;
                grid-template-rows: 15px repeat(6, 38px) 15px;
                gap: 2px;
                padding: 5px;
            }
            
            .cell { min-width: 36px; min-height: 36px; }
            .dot { width: 22px; height: 22px; font-size: 7px; }
            .board-label { font-size: 0.6em; }
            
            .landmines-section {
                width: 100%;
            }
            
            .landmines-label {
                font-size: 0.65em;
            }
            
            .landmines-display {
                min-height: 30px;
                max-height: 40px;
                padding: 3px 6px;
            }
            
            .landmine-card {
                width: 25px;
                height: 30px;
            }
            
            .landmine-card .landmine-icon { font-size: 1.1em; }
            .landmine-card .landmine-label { font-size: 0.5em; }
            
            .right-panel {
                gap: 3px;
                padding: 5px 8px;
                max-height: 145px;
            }
            
            .hand-title { font-size: 0.7em; }
            
            .cards-container {
                gap: 5px;
                min-height: 50px;
                max-height: 54px;
            }
            
            .card {
                min-width: 50px;
                min-height: 46px;
                padding: 4px;
                font-size: 0.65em;
            }
            
            .controls button {
                flex: 1 1 30%;
                min-height: 34px;
                padding: 5px 3px;
                font-size: 0.6em;
            }
            
            /* Mode selection adjustments */
            .mode-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .mode-button {
                width: 90%;
                max-width: 300px;
                padding: 20px;
            }
            
            .join-form {
                width: 95%;
                padding: 20px;
            }
        }
        
        /* Very small phones */
        @media (max-width: 400px) {
            .header h1 { font-size: 0.75em; }
            .turn-info { font-size: 0.65em; }
            
            .player-box {
                padding: 3px;
                font-size: 0.55em;
            }
            
            .score-dot { width: 9px; height: 9px; }
            
            .board {
                grid-template-columns: 12px repeat(6, 34px) 12px;
                grid-template-rows: 12px repeat(6, 34px) 12px;
                padding: 4px;
                gap: 2px;
            }
            
            .cell { min-width: 32px; min-height: 32px; }
            .dot { width: 20px; height: 20px; font-size: 6px; }
            .board-label { font-size: 0.55em; }
            
            .right-panel {
                max-height: 145px;
                padding: 6px;
            }
            
            .cards-container {
                max-height: 48px;
                gap: 4px;
            }
            
            .card {
                min-width: 55px;
                min-height: 42px;
                padding: 4px;
                font-size: 0.65em;
            }
            
            .controls button {
                min-height: 36px;
                font-size: 0.6em;
            }
        }
        
        /* Landscape mode on phones */
        @media (max-height: 500px) and (orientation: landscape) {
            .header {
                padding: 4px 8px;
                min-height: 35px;
            }
            
            .header h1 { font-size: 0.7em; }
            .turn-info { font-size: 0.6em; margin: 2px 0; }
            
            .game-container {
                flex-direction: row;
                gap: 8px;
                padding: 6px;
            }
            
            .center-panel {
                flex-direction: row;
                gap: 8px;
            }
            
            .players-top {
                flex-direction: column;
                width: 100px;
                gap: 4px;
            }
            
            .player-box {
                font-size: 0.55em;
                padding: 3px;
            }
            
            .board-section {
                flex: 1;
            }
            
            .board {
                width: auto;
                height: 100%;
                max-height: calc(100vh - 60px);
                aspect-ratio: 1;
            }
            
            .dot { width: 16px; height: 16px; font-size: 6px; }
            
            .right-panel {
                width: 160px;
                height: 100%;
                flex-direction: column;
                max-height: none;
                border-radius: 0;
            }
            
            .cards-container {
                flex-direction: column;
                overflow-y: auto;
                overflow-x: hidden;
                max-height: none;
                flex: 1;
            }
            
            .card {
                min-width: 100%;
                min-height: 35px;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .controls button {
                flex: 0 0 auto;
                min-height: 32px;
            }
        }
        
        /* Touch-friendly adjustments */
        @media (hover: none) and (pointer: coarse) {
            .card { min-height: 50px; }
            button { min-height: 44px; }
            .cell { min-width: 40px; min-height: 40px; }
        }
    </style>
</head>
<body>
    <!-- Mode Selection Screen -->
    <div id="modeScreen">
        <div class="mode-selection" style="padding: 20px;">
            <div style="text-align: center; margin-bottom: 20px;">
                <img src="Twenty Dots Logo.png" alt="Twenty Dots Logo" style="max-width: min(150px, 30vw); max-height: min(150px, 30vw); object-fit: contain;">
            </div>
            <h2 style="color: #ffd700; font-size: clamp(1.3em, 5vw, 2em); margin-bottom: clamp(20px, 5vh, 40px); text-align: center;">Choose Game Mode</h2>
            <div class="mode-buttons">
                <div class="mode-button" onclick="showJoinScreen()" ontouchend="showJoinScreen()">
                    <div class="mode-icon">üåê</div>
                    <div class="mode-title">Multiplayer</div>
                    <div class="mode-description">Play online with friends<br>2-4 players</div>
                </div>
                <div class="mode-button" onclick="showSinglePlayerScreen()" ontouchend="showSinglePlayerScreen()">
                    <div class="mode-icon">ü§ñ</div>
                    <div class="mode-title">Single Player</div>
                    <div class="mode-description">Play against AI<br>2-4 players</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Join Game Screen -->
    <div id="joinScreen">
        <div class="join-form">
            <h2 style="color: #ffd700; margin-bottom: 30px;">Join a Game</h2>
            <div class="form-group">
                <label>Game ID</label>
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                    <input type="text" id="gameId" placeholder="e.g., game123" oninput="toggleShareButton()" style="flex: 1; min-width: 150px;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false">
                    <button id="shareButton" onclick="shareGameRoom()" disabled style="background: #4CAF50; color: white; border: none; padding: 12px 16px; border-radius: 8px; cursor: pointer; font-size: 14px; opacity: 0.5; white-space: nowrap; min-height: 44px;">
                        üì§ Share
                    </button>
                </div>
            </div>
            <div class="form-group">
                <label>Your Name</label>
                <input type="text" id="playerName" placeholder="e.g., Brandon" autocomplete="name">
            </div>
            <div class="form-group">
                <label>Number of Players</label>
                <select id="playerCount">
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                </select>
            </div>
            <div class="form-group">
                <label>Win Condition (First Player Only)</label>
                <select id="winCondition">
                    <option value="twenty_dots" selected>First to 20 Total Dots (Recommended)</option>
                    <option value="five_colors">First to 5 of Each Color</option>
                    <option value="five_with_yellow">First to 5 of Each Color + 5 Yellow (Hard)</option>
                </select>
            </div>
            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                    <input type="checkbox" id="powerCardsEnabled" checked style="width: 20px; height: 20px; accent-color: #ffd700;">
                    <span>‚ö° Enable Power Cards (Recommended)</span>
                </label>
            </div>
            <div class="form-group">
                <button class="btn-join" onclick="joinGame()">üéÆ Join Game</button>
            </div>
            <div class="form-group" id="rejoinSection" style="display: none;">
                <button class="btn-join" onclick="rejoinGame()" style="background: #4CAF50;">üîÑ Rejoin Last Game</button>
            </div>
            <div class="error-message" id="joinError"></div>
        </div>
    </div>
    
    <!-- Single Player Screen -->
    <div id="singlePlayerScreen" style="display: none; align-items: center; justify-content: center; min-height: 100vh;">
        <div class="join-form">
            <h2 style="color: #ffd700; margin-bottom: 30px;">Single Player Game</h2>
            <div class="form-group">
                <label>Your Name</label>
                <input type="text" id="spPlayerName" placeholder="e.g., Brandon">
            </div>
            <div class="form-group">
                <label>Number of Players (including you)</label>
                <select id="spPlayerCount">
                    <option value="2">2 Players (1 AI)</option>
                    <option value="3">3 Players (2 AI)</option>
                    <option value="4">4 Players (3 AI)</option>
                </select>
            </div>
            <div class="form-group">
                <label>AI Difficulty</label>
                <select id="spDifficulty">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                </select>
            </div>
            <div class="form-group">
                <label>Win Condition</label>
                <select id="spWinCondition">
                    <option value="twenty_dots">First to 20 Total Dots</option>
                    <option value="five_colors">First to 5 of Each Color</option>
                    <option value="five_with_yellow">First to 5 of Each Color + 5 Yellow</option>
                </select>
            </div>
            <div class="form-group">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                    <input type="checkbox" id="spPowerCardsEnabled" checked style="width: 20px; height: 20px; accent-color: #ffd700;">
                    <span>‚ö° Enable Power Cards (Recommended)</span>
                </label>
            </div>
            <div class="form-group">
                <button class="btn-join" onclick="startSinglePlayer()">ü§ñ Start Game</button>
            </div>
            <div class="error-message" id="spError"></div>
        </div>
    </div>
    
    <!-- Main Game Screen -->
    <div id="gameScreen" class="main-container">
        <div style="width: 100%; height: 100%; display: flex; flex-direction: column;">
            <!-- Header -->
            <div class="header">
                <h1>Twenty Dots - Online Multiplayer</h1>
                <div class="turn-info" id="turnInfo">Waiting for game to start...</div>
                <div class="music-controls">
                    <button class="music-toggle" id="musicToggle" onclick="toggleMusic()" title="Toggle Music">
                        üîá
                    </button>
                    <button class="music-toggle skip-btn" id="skipTrack" onclick="skipTrack()" title="Next Track">
                        ‚è≠Ô∏è
                    </button>
                </div>
            </div>
            
            <!-- Game Content -->
            <div class="game-container">
                <!-- Left: Logo and Players -->
                <div class="left-panel">
                    <div class="logo-box">
                        <img src="Twenty Dots Logo.png" alt="Twenty Dots Logo">
                    </div>
                    <!-- Players 2x2 grid (desktop only) -->
                    <div class="players-grid">
                        <div id="playerLeft0" class="player-box"></div>
                        <div id="playerLeft1" class="player-box"></div>
                        <div id="playerLeft2" class="player-box"></div>
                        <div id="playerLeft3" class="player-box"></div>
                    </div>
                </div>
                
                <!-- Center: Landmines and Board -->
                <div class="center-panel">
                    <!-- Mobile-only Players row -->
                    <div class="players-top">
                        <div id="player0" class="player-box"></div>
                        <div id="player1" class="player-box"></div>
                        <div id="player2" class="player-box"></div>
                        <div id="player3" class="player-box"></div>
                    </div>
                    
                    <!-- Active Landmines Display with Label -->
                    <div class="landmines-section">
                        <div class="landmines-label">üí£ Landmines</div>
                        <div id="landminesDisplay" class="landmines-display"></div>
                    </div>
                    
                    <!-- Board -->
                    <div class="board-section">
                        <div class="board" id="gameBoard"></div>
                    </div>
                </div>
                
                <!-- Right: Hand and Controls -->
                <div class="right-panel">
                    <div class="hand-title">Your Hand</div>
                    <div class="cards-container" id="handCards"></div>
                    <div class="controls">
                        <button class="btn-play" id="playBtn" onclick="playCards()" disabled>‚ñ∂Ô∏è Play Cards</button>
                        <button class="btn-roll" id="rollBtn" onclick="rollDice()" disabled>üé≤ Roll Wild Dice</button>
                        <button class="btn-clear" onclick="clearSelection()">üóëÔ∏è Clear Selection</button>
                        <button class="btn-cancel" id="cancelPowerBtn" onclick="cancelPowerCard()" style="display: none; background: #ff6b6b;">‚ùå Cancel Power</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Background Music -->
    <audio id="bgMusic" preload="auto"></audio>

    <script>
        let socket;
        let gameId = '';
        let playerName = '';
        let myHand = [];
        let selectedCards = [];
        let currentGameState = null;
        
        // Music state
        let musicPlaying = false;
        let musicInitialized = false;
        let currentTrackIndex = 0;
        
        // Chill ambient/game music playlist - using Internet Archive (most reliable for web audio)
        const musicPlaylist = [
            'https://ia800605.us.archive.org/8/items/LofiHipHopMusicForStudyingAndRelaxation/Lofi%20Hip%20Hop%20Music%20for%20Studying%20and%20Relaxation.mp3',
            'https://ia803005.us.archive.org/21/items/laborday2019_202001/lofi.mp3',
            'https://ia800501.us.archive.org/10/items/cd_ambient-music-for-studying/disc1/01.%20Artist%20Unknown%20-%20Track%2001_sample.mp3'
        ];
        
        // Swap power card state
        let swapMode = false;
        let swapPositions = [];
        
        // Landmine power card state
        let landmineMode = false;
        
        // Wild place power card state
        let wildPlaceMode = false;
        
        // Block power card state
        let blockMode = false;
        
        // Card swap power card state
        let cardSwapMode = false;
        let cardSwapStep = 'none'; // 'select_own', 'select_opponent', 'select_opponent_cards'
        let cardSwapOwnCards = [];
        let cardSwapOpponent = null;
        let cardSwapOpponentCards = [];
        let cardSwapOpponentHandSize = 0;

        // Random background themes with visible patterns
        const backgroundThemes = [
            'bg-default', 'bg-stars', 'bg-grid', 'bg-hexagon', 'bg-circuit',
            'bg-dots', 'bg-waves', 'bg-triangles', 'bg-plasma', 'bg-diamond'
        ];
        
        function setRandomBackground() {
            const randomIndex = Math.floor(Math.random() * backgroundThemes.length);
            const theme = backgroundThemes[randomIndex];
            document.body.className = theme;
            console.log('Background theme set to:', theme);
        }
        
        // Set random background on page load
        setRandomBackground();

        // Mobile viewport height fix (handles address bar hide/show)
        function setMobileViewportHeight() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        
        // Set initial viewport height
        setMobileViewportHeight();
        
        // Update on resize and orientation change
        window.addEventListener('resize', setMobileViewportHeight);
        window.addEventListener('orientationchange', () => {
            setTimeout(setMobileViewportHeight, 100);
        });
        
        // Prevent double-tap zoom on buttons and cards (but not on mode buttons which need click events)
        document.addEventListener('touchend', function(e) {
            // Only handle CARDS and CELLS in the game screen
            const target = e.target.closest('.card, .cell');
            const isGameScreen = document.getElementById('gameScreen').classList.contains('active');
            if (target && isGameScreen) {
                e.preventDefault();
                // Manually trigger click event since we prevented default
                target.click();
            }
        }, { passive: false });
        
        // Prevent pull-to-refresh on mobile during game
        let touchStartY = 0;
        document.addEventListener('touchstart', function(e) {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        document.addEventListener('touchmove', function(e) {
            const touchY = e.touches[0].clientY;
            const scrollableElement = e.target.closest('.cards-container, .right-panel');
            
            // Only prevent default if we're at the top of the page and swiping down
            if (!scrollableElement && touchY > touchStartY && window.scrollY === 0) {
                // Allow default behavior on forms
                if (!e.target.closest('input, select, textarea, .join-form')) {
                    e.preventDefault();
                }
            }
        }, { passive: false });

        // Check for saved game on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Check for game ID in URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            const urlGameId = urlParams.get('gameId');
            if (urlGameId) {
                document.getElementById('gameId').value = urlGameId;
                console.log('Loaded game ID from URL:', urlGameId);
            }
            
            const savedGame = localStorage.getItem('currentGame');
            if (savedGame) {
                try {
                    const gameInfo = JSON.parse(savedGame);
                    // Check if game is less than 24 hours old
                    const ageHours = (Date.now() - gameInfo.timestamp) / (1000 * 60 * 60);
                    if (ageHours < 24) {
                        document.getElementById('rejoinSection').style.display = 'block';
                    } else {
                        localStorage.removeItem('currentGame');
                    }
                } catch (e) {
                    localStorage.removeItem('currentGame');
                }
            }
        });

        function showJoinScreen() {
            document.getElementById('modeScreen').style.display = 'none';
            document.getElementById('joinScreen').style.display = 'flex';
        }

        function showSinglePlayerScreen() {
            document.getElementById('modeScreen').style.display = 'none';
            document.getElementById('singlePlayerScreen').style.display = 'flex';
        }

        function showSinglePlayerMessage() {
            alert('ü§ñ Single Player Mode\n\nThe web version currently supports multiplayer only.\n\nFor single-player with AI opponents, please download and run the desktop version.');
        }

        function joinGame() {
            gameId = document.getElementById('gameId').value.trim();
            playerName = document.getElementById('playerName').value.trim();
            const gameMode = document.getElementById('winCondition').value || 'twenty_dots';
            const playerCount = parseInt(document.getElementById('playerCount').value);
            const powerCardsEnabled = document.getElementById('powerCardsEnabled').checked;
            
            if (!gameId || !playerName) {
                showError('joinError', 'Please enter Game ID and your name');
                return;
            }
            
            const serverUrl = window.location.origin;
            console.log('Connecting to:', serverUrl);
            socket = io(serverUrl);
            
            socket.on('connect', () => {
                console.log('Connected to server');
                socket.emit('join_game', {
                    game_id: gameId,
                    player_name: playerName,
                    game_mode: gameMode,
                    player_count: playerCount,
                    power_cards: powerCardsEnabled
                });
            });
            
            setupSocketHandlers();
        }

        function rejoinGame() {
            const savedGame = localStorage.getItem('currentGame');
            if (!savedGame) {
                showError('joinError', 'No saved game found');
                return;
            }
            
            const gameInfo = JSON.parse(savedGame);
            gameId = gameInfo.gameId;
            playerName = gameInfo.playerName;
            
            // Populate the form fields
            document.getElementById('gameId').value = gameId;
            document.getElementById('playerName').value = playerName;
            
            const serverUrl = window.location.origin;
            console.log('Rejoining game:', gameId);
            socket = io(serverUrl);
            
            socket.on('connect', () => {
                console.log('Connected to server, rejoining...');
                socket.emit('join_game', {
                    game_id: gameId,
                    player_name: playerName,
                    game_mode: 'twenty_dots',  // Default, server will use existing game mode
                    player_count: 4  // Default, server will use existing player count
                });
            });
            
            setupSocketHandlers();
        }

        function startSinglePlayer() {
            playerName = document.getElementById('spPlayerName').value || 'Player';
            const numPlayers = parseInt(document.getElementById('spPlayerCount').value);
            const difficulty = document.getElementById('spDifficulty').value;
            const gameMode = document.getElementById('spWinCondition').value;
            const powerCardsEnabled = document.getElementById('spPowerCardsEnabled').checked;
            
            if (!playerName) {
                showError('spError', 'Please enter your name');
                return;
            }
            
            const serverUrl = window.location.origin;
            console.log('Connecting to:', serverUrl);
            socket = io(serverUrl);
            
            // Setup handlers BEFORE connecting
            setupSocketHandlers();
            
            socket.on('connect', () => {
                console.log('Connected to server for single-player');
                socket.emit('start_single_player', {
                    player_name: playerName,
                    num_players: numPlayers,
                    difficulty: difficulty,
                    game_mode: gameMode,
                    power_cards: powerCardsEnabled
                });
            });
        }

        function setupSocketHandlers() {
            socket.on('join_success', () => {
                document.getElementById('joinScreen').style.display = 'none';
                document.getElementById('singlePlayerScreen').style.display = 'none';
                document.getElementById('gameScreen').classList.add('active');
            });
            
            socket.on('game_started', (gameState) => {
                console.log('Game started!', gameState);
                // Capture game_id from the game state (for single-player and multiplayer)
                if (gameState.game_id) {
                    gameId = gameState.game_id;
                    console.log('Set gameId to:', gameId);
                    // Save game info to localStorage for rejoin
                    localStorage.setItem('currentGame', JSON.stringify({
                        gameId: gameId,
                        playerName: playerName,
                        timestamp: Date.now()
                    }));
                }
                // Hide both forms and show game screen
                document.getElementById('joinScreen').style.display = 'none';
                document.getElementById('singlePlayerScreen').style.display = 'none';
                document.getElementById('gameScreen').classList.add('active');
                updateGameState(gameState);
            });
            
            socket.on('game_updated', (gameState) => {
                console.log('=== GAME_UPDATED ===');
                console.log('Board:', gameState.board);
                console.log('Current turn:', gameState.current_turn);
                console.log('Can roll dice:', gameState.can_roll_dice);
                console.log('Yellow dot position:', gameState.yellow_dot_position);
                updateGameState(gameState);
            });
            
            socket.on('your_hand', (data) => {
                console.log('=== YOUR_HAND ===');
                console.log('Received', data.hand.length, 'cards');
                console.log('Hand:', data.hand);
                myHand = data.hand;
                // Reset cardSwapOwnCards when hand updates (indices are now invalid)
                if (cardSwapMode && cardSwapStep === 'select_own') {
                    cardSwapOwnCards = [];
                    console.log('Card swap mode: reset own card selections due to hand update');
                }
                updateHand();
            });
            
            socket.on('error', (data) => {
                console.log('Error:', data.message);
                // Show error to user
                alert('‚ùå ' + data.message);
            });
            
            socket.on('game_over', (data) => {
                console.log('GAME OVER!', data);
                const winner = data.winner;
                const condition = data.condition;
                
                let conditionText = '';
                if (condition === 'twenty_dots') {
                    conditionText = 'First to reach 20 total dots!';
                } else if (condition === 'five_colors') {
                    conditionText = 'First to collect 5 of each color!';
                } else if (condition === 'five_with_yellow') {
                    conditionText = 'First to collect 5 of each color including yellow!';
                } else if (condition === 'deck_empty') {
                    conditionText = 'Deck ran out - most dots wins!';
                }
                
                // Track wins/losses in localStorage
                const stats = JSON.parse(localStorage.getItem('playerStats') || '{}');
                if (!stats[playerName]) stats[playerName] = { wins: 0, losses: 0 };
                if (winner === playerName) {
                    stats[playerName].wins += 1;
                } else {
                    stats[playerName].losses += 1;
                }
                localStorage.setItem('playerStats', JSON.stringify(stats));
                
                // Clear saved game on game over
                localStorage.removeItem('currentGame');
                
                setTimeout(() => {
                    const playAgain = confirm(`üéâ ${winner} WINS! üéâ\n\n${conditionText}\n\nClick OK to play again, or Cancel to go back to lobby`);
                    if (playAgain) {
                        location.reload();
                    } else {
                        location.href = window.location.origin;
                    }
                }, 500);
            });
            
            // Handle swap power card - need to select two dots on board
            socket.on('select_swap_dots', (data) => {
                console.log('=== SELECT_SWAP_DOTS EVENT RECEIVED ===');
                console.log('Message:', data.message);
                swapMode = true;
                swapPositions = [];
                console.log('swapMode set to:', swapMode);
                // Use non-blocking notification instead of alert
                showNotification('üîÑ SWAP POWER: Click two dots on the board to swap them!', 'info');
                // Highlight that we're in swap mode
                document.getElementById('gameBoard').style.cursor = 'crosshair';
                // Add visual hint to all cells with dots
                document.querySelectorAll('.cell').forEach(cell => {
                    if (cell.querySelector('.dot')) {
                        cell.style.outline = '2px dashed #FFD700';
                    }
                });
                // Show cancel button
                showCancelButton();
            });
            
            // Handle landmine power card - need to select a sacrifice card
            socket.on('select_landmine_sacrifice', (data) => {
                console.log('Select landmine sacrifice:', data.message);
                landmineMode = true;
                showNotification('üí• LANDMINE: Click a card with an EMPTY board location to place landmine!', 'warning');
                showCancelButton();
            });
            
            // Handle landmine placement confirmation
            socket.on('landmine_placed', (data) => {
                console.log('Landmine placed:', data);
                // Show notification
                showNotification(`üí• ${data.player} placed a landmine!`, 'warning');
                hideCancelButton();
            });
            
            // Handle landmine detonation
            socket.on('landmine_detonated', (data) => {
                console.log('LANDMINE DETONATED:', data);
                // Show dramatic explosion notification
                alert(`üí•üí•üí• BOOM! üí•üí•üí•\n\nLandmine at ${data.location} detonated!\n\nTriggered by: ${data.triggered_by}\nPlaced by: ${data.placed_by}\nDots removed: ${data.removed_count}\nPenalty color: ${data.color}`);
            });
            
            // Handle dot removed (bomb power card)
            socket.on('dot_removed', (data) => {
                console.log('Dot removed:', data);
                showNotification(`üí£ ${data.player} used BOMB! Removed ${data.color} dot at ${data.position}!`, 'warning');
            });
            
            // Handle wild place power card - select position on board
            socket.on('select_wild_position', (data) => {
                console.log('Select wild position:', data.message);
                wildPlaceMode = true;
                showNotification('‚≠ê WILD PLACE: Click any position on the board!', 'info');
                // Highlight that we're in wild place mode
                document.getElementById('gameBoard').style.cursor = 'crosshair';
                showCancelButton();
            });
            
            // Handle block power card - select empty position on board
            socket.on('select_block_position', (data) => {
                console.log('Select block position:', data.message);
                blockMode = true;
                showNotification('üö´ BLOCK: Click an empty cell to block it for 3 turns!', 'info');
                // Highlight that we're in block mode
                document.getElementById('gameBoard').style.cursor = 'crosshair';
                // Add visual hint to empty cells
                document.querySelectorAll('.cell').forEach(cell => {
                    if (!cell.querySelector('.dot')) {
                        cell.style.outline = '2px dashed #FF4444';
                    }
                });
                showCancelButton();
            });
            
            // Handle block placed confirmation
            socket.on('block_placed', (data) => {
                console.log('Block placed:', data);
                showNotification(`üö´ ${data.player} blocked cell ${data.position} for ${data.rounds_remaining} rounds!`, 'warning');
            });
            
            // Handle card swap power card - multi-step process
            socket.on('select_card_swap', (data) => {
                console.log('Card swap initiated:', data);
                cardSwapMode = true;
                cardSwapStep = 'select_own';
                cardSwapOwnCards = [];
                cardSwapOpponent = null;
                cardSwapOpponentCards = [];
                showNotification('üîÑ CARD SWAP: Select 2 cards from your hand to give away', 'info');
                showCancelButton();
                updateHand(); // Re-render hand to show swap mode
            });
            
            // Handle card swap opponent selection prompt
            socket.on('select_card_swap_opponent', (data) => {
                console.log('Select opponent for card swap:', data);
                cardSwapStep = 'select_opponent';
                showOpponentSelectModal(data.opponents);
            });
            
            // Handle card swap opponent cards selection prompt  
            socket.on('select_opponent_cards_for_swap', (data) => {
                console.log('Select opponent cards for swap:', data);
                cardSwapStep = 'select_opponent_cards';
                cardSwapOpponentHandSize = data.hand_size;
                showOpponentCardsModal(data.opponent, data.hand_size);
            });
            
            // Handle card swap completion
            socket.on('card_swap_complete', (data) => {
                console.log('Card swap complete:', data);
                cardSwapMode = false;
                cardSwapStep = 'none';
                cardSwapOwnCards = [];
                cardSwapOpponent = null;
                cardSwapOpponentCards = [];
                hideCancelButton();
                alert(`üîÑ Card swap complete!\n\nYou gave: ${data.gave.join(', ')}\nYou received: ${data.received.join(', ')}`);
            });
        }


        function updateGameState(state) {
            currentGameState = state;
            updateBoard(state.board, state.yellow_dot_position);
            updatePlayers(state.players, state.current_turn);
            updateTurnInfo(state.current_turn);
            updateLandminesDisplay(state.landmines || []);
            
            const isMyTurn = state.current_turn === playerName;
            const canRoll = state.can_roll_dice || false;
            
            // Show/hide entire hand section based on whose turn it is
            // Use visibility instead of display to preserve layout and positioning
            const handSection = document.querySelector('.right-panel');
            const controlsSection = document.querySelector('.controls');
            if (isMyTurn) {
                handSection.style.visibility = 'visible';
                handSection.style.pointerEvents = 'auto';
                controlsSection.style.visibility = 'visible';
                controlsSection.style.pointerEvents = 'auto';
            } else {
                handSection.style.visibility = 'hidden';
                handSection.style.pointerEvents = 'none';
                controlsSection.style.visibility = 'hidden';
                controlsSection.style.pointerEvents = 'none';
            }
            
            // Roll Dice button: only visible when it's your turn, enabled only when can_roll_dice is true
            document.getElementById('rollBtn').style.display = isMyTurn ? 'block' : 'none';
            document.getElementById('rollBtn').disabled = !canRoll;
            
            // Play Cards button: only enabled if you have cards selected AND you've already rolled (canRoll is false)
            document.getElementById('playBtn').style.display = isMyTurn ? 'block' : 'none';
            document.getElementById('playBtn').disabled = selectedCards.length === 0 || canRoll;
            
            // Disable card selection if player must roll first
            const cardDivs = document.querySelectorAll('.card');
            cardDivs.forEach(card => {
                if (!isMyTurn || canRoll) {
                    card.style.pointerEvents = 'none';
                    card.style.opacity = '0.5';
                } else {
                    card.style.pointerEvents = 'auto';
                    card.style.opacity = '1';
                }
            });
        }

        function updateBoard(board, yellowDotPosition) {
            console.log('UPDATE_BOARD: Rendering board with', board.length, 'rows');
            let dotCount = 0;
            for (let r = 0; r < board.length; r++) {
                for (let c = 0; c < board[r].length; c++) {
                    if (board[r][c]) dotCount++;
                }
            }
            console.log('UPDATE_BOARD: Total dots on board:', dotCount);
            const boardDiv = document.getElementById('gameBoard');
            boardDiv.innerHTML = '';
            
            const rows = ['A', 'B', 'C', 'D', 'E', 'F'];
            const cols = ['1', '2', '3', '4', '5', '6'];
            
            // Top row: empty corner + column headers + empty corner
            boardDiv.appendChild(document.createElement('div'));
            cols.forEach(col => {
                const label = document.createElement('div');
                label.className = 'board-label';
                label.textContent = col;
                boardDiv.appendChild(label);
            });
            boardDiv.appendChild(document.createElement('div'));
            
            // Middle rows: row label + cells + row label
            for (let r = 0; r < 6; r++) {
                // Left row label
                const labelLeft = document.createElement('div');
                labelLeft.className = 'board-label';
                labelLeft.textContent = rows[r];
                boardDiv.appendChild(labelLeft);
                
                // Cells
                for (let c = 0; c < 6; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // Add click handler for swap mode
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    
                    // Check if this cell is blocked
                    const isBlocked = currentGameState && currentGameState.blocks && 
                        currentGameState.blocks.some(b => b.row === r && b.col === c);
                    
                    if (isBlocked) {
                        cell.classList.add('blocked');
                        const blockIndicator = document.createElement('div');
                        blockIndicator.className = 'block-indicator';
                        blockIndicator.textContent = 'üö´';
                        const block = currentGameState.blocks.find(b => b.row === r && b.col === c);
                        blockIndicator.title = `Blocked for ${block.rounds_remaining || 1} more round(s)`;
                        cell.appendChild(blockIndicator);
                    }
                    
                    if (board[r] && board[r][c]) {
                        const dot = document.createElement('div');
                        dot.className = `dot ${board[r][c].color}`;
                        cell.appendChild(dot);
                        
                        // Highlight selected swap positions
                        if (swapMode && swapPositions.some(p => p.row === r && p.col === c)) {
                            cell.classList.add('swap-selected');
                        }
                    }
                    
                    boardDiv.appendChild(cell);
                }
                
                // Right row label
                const labelRight = document.createElement('div');
                labelRight.className = 'board-label';
                labelRight.textContent = rows[r];
                boardDiv.appendChild(labelRight);
            }
            
            // Bottom row: empty corner + column headers + empty corner
            boardDiv.appendChild(document.createElement('div'));
            cols.forEach(col => {
                const label = document.createElement('div');
                label.className = 'board-label';
                label.textContent = col;
                boardDiv.appendChild(label);
            });
            boardDiv.appendChild(document.createElement('div'));
        }
        
        function updateLandminesDisplay(landmines) {
            const displayDiv = document.getElementById('landminesDisplay');
            if (!displayDiv) return;
            
            displayDiv.innerHTML = '';
            
            if (landmines.length === 0) {
                return;
            }
            
            landmines.forEach((mine, index) => {
                const mineCard = document.createElement('div');
                mineCard.className = 'landmine-card';
                
                // Show location only if it's the player's own mine
                const isMyMine = mine.player === playerName;
                const locationText = isMyMine ? mine.location : '???';
                
                mineCard.innerHTML = `
                    <div class="landmine-icon">üí•</div>
                    <div class="landmine-label">${locationText}</div>
                `;
                
                // Add tooltip with more info for own mines
                if (isMyMine) {
                    mineCard.title = `Your landmine at ${mine.location} (${mine.color} penalty)`;
                    mineCard.style.borderColor = '#FFD700';
                } else {
                    mineCard.title = `${mine.player}'s landmine (location hidden)`;
                }
                
                displayDiv.appendChild(mineCard);
            });
        }

        function updatePlayers(players, currentTurn) {
            const playerArray = Object.entries(players);
            // Update both mobile (player0-3) and desktop (playerLeft0-3) boxes
            const playerIdSets = [
                ['player0', 'player1', 'player2', 'player3'],
                ['playerLeft0', 'playerLeft1', 'playerLeft2', 'playerLeft3']
            ];
            
            playerIdSets.forEach(playerIds => {
                playerIds.forEach((playerId, idx) => {
                    const playerBox = document.getElementById(playerId);
                    if (!playerBox) return;
                    playerBox.innerHTML = '';
                    playerBox.classList.remove('active', 'me');
                    
                    if (idx < playerArray.length) {
                        const [name, data] = playerArray[idx];
                        if (name === currentTurn) playerBox.classList.add('active');
                        if (name === playerName) playerBox.classList.add('me');
                        
                        const nameDiv = document.createElement('div');
                        nameDiv.className = 'player-name';
                        nameDiv.textContent = name + (name === playerName ? ' (You)' : '');
                        playerBox.appendChild(nameDiv);
                        
                        const scoreDiv = document.createElement('div');
                        scoreDiv.className = 'player-score';
                        scoreDiv.textContent = `${data.total_dots} dots`;
                        playerBox.appendChild(scoreDiv);
                        
                        const colorsDiv = document.createElement('div');
                        colorsDiv.className = 'player-score-dots';
                        ['red', 'blue', 'purple', 'green'].forEach(color => {
                            const scoreDot = document.createElement('div');
                            scoreDot.className = `score-dot dot ${color}`;
                            scoreDot.textContent = data.score ? (data.score[color] || 0) : 0;
                            colorsDiv.appendChild(scoreDot);
                        });
                        
                        // Add yellow dot display if game mode is five_with_yellow
                        if (currentGameState && currentGameState.game_mode === 'five_with_yellow') {
                            const yellowDot = document.createElement('div');
                            yellowDot.className = 'score-dot dot yellow';
                            yellowDot.textContent = data.yellow_dots || 0;
                            colorsDiv.appendChild(yellowDot);
                        }
                        
                        playerBox.appendChild(colorsDiv);
                        
                        const handDiv = document.createElement('div');
                        handDiv.className = 'player-hand';
                        handDiv.textContent = `Hand: ${data.hand_size}/5`;
                        playerBox.appendChild(handDiv);
                        
                        // Add discard pile (always show, even if empty)
                        const discardPile = data.discard_pile || [];
                        const discardLabel = document.createElement('div');
                        discardLabel.className = 'player-discard';
                        discardLabel.textContent = `Discard: ${discardPile.length}`;
                        playerBox.appendChild(discardLabel);
                        
                        const discardContainer = document.createElement('div');
                        discardContainer.className = 'discard-cards';
                        if (discardPile.length > 0) {
                            // Show last 2 cards as card boxes
                            const lastCards = discardPile.slice(-2);
                            lastCards.forEach(card => {
                                const cardDiv = document.createElement('div');
                                cardDiv.className = `card ${card.color}`;
                                cardDiv.style.width = '50px';
                                cardDiv.style.minHeight = '42px';
                                cardDiv.style.fontSize = '0.7em';
                                cardDiv.style.padding = '4px';
                                cardDiv.style.flexShrink = '0';
                                cardDiv.style.flexBasis = 'auto';
                                cardDiv.innerHTML = `<div>${card.location}</div><div style="font-size: 0.7em; opacity: 0.8;">${card.color.toUpperCase()}</div>`;
                                discardContainer.appendChild(cardDiv);
                            });
                        }
                        playerBox.appendChild(discardContainer);
                        
                        // Add wins/losses stats
                        const stats = JSON.parse(localStorage.getItem('playerStats') || '{}');
                        const playerStats = stats[name] || { wins: 0, losses: 0 };
                        const statsDiv = document.createElement('div');
                        statsDiv.style.marginTop = '8px';
                        statsDiv.style.fontSize = '0.85em';
                        statsDiv.style.color = '#4CAF50';
                        statsDiv.style.textAlign = 'center';
                        statsDiv.innerHTML = `<div style="font-weight: bold;">Wins: ${playerStats.wins} | Loss: ${playerStats.losses}</div>`;
                        playerBox.appendChild(statsDiv);
                    }
                });
            });
        }

        function updateTurnInfo(currentTurn) {
            const turnDiv = document.getElementById('turnInfo');
            if (currentTurn === playerName) {
                turnDiv.textContent = '‚≠ê YOUR TURN!';
                turnDiv.style.color = '#4CAF50';
            } else {
                turnDiv.textContent = `‚è≥ ${currentTurn}'s Turn`;
                turnDiv.style.color = '#ff6b6b';
            }
        }

        function updateHand() {
            const handDiv = document.getElementById('handCards');
            handDiv.innerHTML = '';
            
            // Show card swap mode indicator
            if (cardSwapMode && cardSwapStep === 'select_own') {
                const indicator = document.createElement('div');
                indicator.className = 'card-swap-indicator';
                indicator.style.cssText = 'background: linear-gradient(135deg, #FFD700, #FFA500); color: black; padding: 8px; border-radius: 5px; margin-bottom: 10px; text-align: center; font-weight: bold; animation: pulse 1s infinite;';
                indicator.innerHTML = `üîÑ SELECT 2 CARDS TO SWAP (${cardSwapOwnCards.length}/2)`;
                handDiv.appendChild(indicator);
            }
            
            myHand.forEach((card, index) => {
                const cardDiv = document.createElement('div');
                cardDiv.className = `card ${card.color}`;
                
                // Highlight if this card is selected for swap
                if (cardSwapMode && cardSwapOwnCards.includes(index)) {
                    cardDiv.style.border = '3px solid #00ff00';
                    cardDiv.style.boxShadow = '0 0 15px rgba(0,255,0,0.5)';
                }
                
                // Check if it's a power card
                if (card.power) {
                    // Power card styling with purple/magenta border (distinct from gold selection)
                    if (!cardSwapOwnCards.includes(index)) {
                        cardDiv.style.border = '3px solid #FF00FF';
                        cardDiv.style.boxShadow = '0 0 10px rgba(255,0,255,0.5)';
                    }
                    
                    // Get power icon
                    const powerIcons = {
                        'swap': '‚ÜîÔ∏è',
                        'remove': 'üí£',
                        'wild_place': '‚≠ê',
                        'block': 'üö´',
                        'card_swap': 'üîÑ',
                        'landmine': 'üí•'
                    };
                    const powerIcon = powerIcons[card.power] || '‚ö°';
                    
                    // Power card display
                    cardDiv.innerHTML = `
                        <div class="card-location" style="color: white;">‚ö° POWER</div>
                        <div style="font-size: 1.5em; margin: 2px 0;">${powerIcon}</div>
                        <div class="card-color" style="color: white; font-size: 0.7em;">${card.power_description || card.power.replace('_', ' ').toUpperCase()}</div>
                    `;
                } else {
                    // Regular card display
                    cardDiv.innerHTML = `<div class="card-location">${card.location[0]}${card.location[1]}</div><div class="card-color">${card.color.toUpperCase()}</div>`;
                }
                
                cardDiv.onclick = () => toggleCardSelection(index, cardDiv);
                handDiv.appendChild(cardDiv);
            });
        }

        function toggleCardSelection(index, cardDiv) {
            // Prevent card selection if dice hasn't been rolled yet
            const canRoll = currentGameState && currentGameState.can_roll_dice;
            if (canRoll && !landmineMode && !cardSwapMode) {
                console.log('Cannot select cards - must roll dice first');
                return;
            }
            
            const card = myHand[index];
            
            // Handle landmine mode - select sacrifice card
            if (landmineMode) {
                // Can't sacrifice a power card
                if (card.power) {
                    alert('‚ùå Cannot sacrifice a power card! Select a regular card.');
                    return;
                }
                
                // Check if location is empty on the board
                const row = card.location[0];
                const col = card.location[1];
                const rowIdx = ['A', 'B', 'C', 'D', 'E', 'F'].indexOf(row);
                const colIdx = parseInt(col) - 1;
                
                if (currentGameState && currentGameState.board[rowIdx] && currentGameState.board[rowIdx][colIdx]) {
                    alert(`‚ùå Location ${row}${col} is not empty! Landmines can only be placed on empty spaces.`);
                    return;
                }
                
                // Confirm sacrifice
                if (confirm(`üí• Sacrifice ${card.color.toUpperCase()} card at ${row}${col} to place landmine?\n\nThe landmine will be placed at this empty location.`)) {
                    console.log('Placing landmine with sacrifice card:', card);
                    socket.emit('place_landmine', {
                        game_id: gameId,
                        sacrifice_card: {
                            color: card.color,
                            location: card.location
                        }
                    });
                    landmineMode = false;
                }
                return;
            }
            
            // Handle card swap mode - selecting own cards to give away
            if (cardSwapMode && cardSwapStep === 'select_own') {
                const card = myHand[index];
                console.log('Card swap selection - clicked card:', card, 'at index:', index);
                console.log('Current cardSwapOwnCards:', cardSwapOwnCards);
                
                // Can't swap a power card
                if (card.power) {
                    alert('‚ùå Cannot swap power cards!');
                    return;
                }
                
                // Toggle selection
                const cardIdx = cardSwapOwnCards.indexOf(index);
                if (cardIdx > -1) {
                    // Deselect
                    cardSwapOwnCards.splice(cardIdx, 1);
                    cardDiv.classList.remove('selected');
                    cardDiv.style.border = '';
                    cardDiv.style.boxShadow = '';
                    console.log('Deselected card, cardSwapOwnCards now:', cardSwapOwnCards);
                } else if (cardSwapOwnCards.length < 2) {
                    // Select
                    cardSwapOwnCards.push(index);
                    cardDiv.classList.add('selected');
                    cardDiv.style.border = '3px solid #00ff00';
                    cardDiv.style.boxShadow = '0 0 15px rgba(0,255,0,0.5)';
                    console.log('Selected card, cardSwapOwnCards now:', cardSwapOwnCards);
                }
                
                // Update the indicator in the hand display
                const handDiv = document.getElementById('handCards');
                let indicator = handDiv.querySelector('.card-swap-indicator');
                if (indicator) {
                    indicator.innerHTML = `üîÑ SELECT 2 CARDS TO SWAP (${cardSwapOwnCards.length}/2)`;
                }
                
                // If 2 cards selected, proceed to opponent selection
                if (cardSwapOwnCards.length === 2) {
                    const selectedCardsData = cardSwapOwnCards.map(i => myHand[i]);
                    console.log('Card swap - sending to server, gameId:', gameId, 'selected own cards:', selectedCardsData);
                    
                    if (!gameId) {
                        console.error('Card swap error: gameId is not set!');
                        alert('Error: Game ID is not set. Please refresh and rejoin the game.');
                        return;
                    }
                    
                    // Change step immediately to prevent reset from hand updates
                    cardSwapStep = 'waiting_for_opponent_list';
                    
                    // Send to server
                    socket.emit('card_swap_action', {
                        game_id: gameId,
                        step: 'select_own_cards',
                        cards: selectedCardsData.map(c => ({
                            color: c.color,
                            location: c.location,
                            power: c.power || null
                        }))
                    });
                }
                return;
            }
            
            if (selectedCards.includes(index)) {
                selectedCards.splice(selectedCards.indexOf(index), 1);
                cardDiv.classList.remove('selected');
            } else if (selectedCards.length < 2) {
                // Power cards can only be played alone
                if (card.power && selectedCards.length > 0) {
                    alert('‚ö° Power cards must be played alone!');
                    return;
                }
                // If a power card is already selected, can't add more cards
                if (selectedCards.length > 0 && myHand[selectedCards[0]].power) {
                    alert('‚ö° Power cards must be played alone!');
                    return;
                }
                
                selectedCards.push(index);
                cardDiv.classList.add('selected');
            }
            
            const isMyTurn = currentGameState && currentGameState.current_turn === playerName;
            document.getElementById('playBtn').disabled = !isMyTurn || selectedCards.length === 0;
        }

        function playCards() {
            if (selectedCards.length === 0) return;
            
            const cards = selectedCards.map(i => myHand[i]);
            
            // Validate power card rules
            const hasPowerCard = cards.some(c => c.power);
            if (hasPowerCard && cards.length > 1) {
                alert('‚ö° Power cards must be played alone!');
                return;
            }
            
            console.log('PLAY_CARDS: Sending cards:', cards);
            console.log('PLAY_CARDS: Current game state:', currentGameState);
            socket.emit('play_cards', {
                game_id: gameId,
                cards: cards
            });
            
            selectedCards = [];
            document.querySelectorAll('.card.selected').forEach(card => {
                card.classList.remove('selected');
            });
        }

        function rollDice() {
            socket.emit('roll_dice', { game_id: gameId });
        }

        function handleCellClick(row, col) {
            // Handle wild place mode - select any position for the wild dot
            if (wildPlaceMode) {
                const rowLetter = ['A', 'B', 'C', 'D', 'E', 'F'][row];
                const colNumber = col + 1;
                
                if (confirm(`‚≠ê Place wild dot at ${rowLetter}${colNumber}?`)) {
                    console.log('Placing wild at:', row, col);
                    socket.emit('place_wild', {
                        game_id: gameId,
                        position: {row: row, col: col}
                    });
                    
                    wildPlaceMode = false;
                    document.getElementById('gameBoard').style.cursor = 'default';
                    hideCancelButton();
                }
                return;
            }
            
            // Handle block mode - select empty position
            if (blockMode) {
                const rowLetter = ['A', 'B', 'C', 'D', 'E', 'F'][row];
                const colNumber = col + 1;
                
                // Check if cell is empty
                if (currentGameState && currentGameState.board[row] && currentGameState.board[row][col]) {
                    alert('‚ùå Can only block empty cells!');
                    return;
                }
                
                // Check if cell is already blocked
                if (currentGameState && currentGameState.blocks) {
                    const isBlocked = currentGameState.blocks.some(b => b.row === row && b.col === col);
                    if (isBlocked) {
                        alert('‚ùå This cell is already blocked!');
                        return;
                    }
                }
                
                if (confirm(`üö´ Block cell ${rowLetter}${colNumber} for 3 turns?`)) {
                    console.log('Blocking cell at:', row, col);
                    socket.emit('place_block', {
                        game_id: gameId,
                        position: {row: row, col: col}
                    });
                    
                    blockMode = false;
                    document.getElementById('gameBoard').style.cursor = 'default';
                    document.querySelectorAll('.cell').forEach(cell => {
                        cell.style.outline = '';
                    });
                    hideCancelButton();
                }
                return;
            }
            
            // Only handle clicks when in swap mode
            if (!swapMode) return;
            
            // Debug logging for swap selection
            console.log('[SWAP_CLICK] Clicked cell:', row, col);
            console.log('[SWAP_CLICK] currentGameState exists:', !!currentGameState);
            if (currentGameState) {
                console.log('[SWAP_CLICK] board[row]:', currentGameState.board[row]);
                console.log('[SWAP_CLICK] board[row][col]:', currentGameState.board[row] ? currentGameState.board[row][col] : 'row undefined');
            }
            
            // Check if there's a dot at this position (check visual cell as fallback)
            const cellHasDot = currentGameState && currentGameState.board[row] && currentGameState.board[row][col];
            const visualCell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            const visualHasDot = visualCell && visualCell.querySelector('.dot');
            
            console.log('[SWAP_CLICK] Data has dot:', cellHasDot, 'Visual has dot:', !!visualHasDot);
            
            // Allow selection if EITHER the data or visual shows a dot
            // This handles potential sync issues between state and display
            if (!cellHasDot && !visualHasDot) {
                alert('Please click on a cell with a dot');
                return;
            }
            
            // Check if the dot is yellow (wild) - these cannot be swapped
            const dotColor = cellHasDot ? currentGameState.board[row][col].color : null;
            if (dotColor === 'yellow') {
                alert('‚ùå Cannot swap the wild (yellow) dot!');
                return;
            }
            
            // Check if already selected
            const existingIdx = swapPositions.findIndex(p => p.row === row && p.col === col);
            if (existingIdx >= 0) {
                // Deselect
                swapPositions.splice(existingIdx, 1);
                console.log('Deselected position:', row, col);
            } else if (swapPositions.length < 2) {
                // Add to selection
                swapPositions.push({row: row, col: col});
                console.log('Selected position:', row, col, 'Total:', swapPositions.length);
            }
            
            // Re-render board to show selection
            updateBoard(currentGameState.board, currentGameState.yellow_dot_position);
            
            // Re-apply swap mode visual hints (updateBoard clears them)
            if (swapMode) {
                document.querySelectorAll('.cell').forEach(cell => {
                    if (cell.querySelector('.dot')) {
                        cell.style.outline = '2px dashed #FFD700';
                    }
                });
            }
            
            // If we have 2 positions selected, send to server
            if (swapPositions.length === 2) {
                console.log('Sending swap_dots:', swapPositions);
                socket.emit('swap_dots', {
                    game_id: gameId,
                    pos1: swapPositions[0],
                    pos2: swapPositions[1]
                });
                
                // Reset swap mode and clear visual hints
                swapMode = false;
                swapPositions = [];
                document.getElementById('gameBoard').style.cursor = 'default';
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.style.outline = '';
                });
                hideCancelButton();
            }
        }

        function endTurn() {
            socket.emit('end_turn', { game_id: gameId });
            selectedCards = [];
            document.querySelectorAll('.card.selected').forEach(card => {
                card.classList.remove('selected');
            });
        }

        function clearSelection() {
            selectedCards = [];
            document.querySelectorAll('.card.selected').forEach(card => {
                card.classList.remove('selected');
            });
            const isMyTurn = currentGameState && currentGameState.current_turn === playerName;
            document.getElementById('playBtn').disabled = !isMyTurn || selectedCards.length === 0;
        }

        function showError(elementId, message) {
            const errorDiv = document.getElementById(elementId);
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
            setTimeout(() => errorDiv.classList.remove('show'), 5000);
        }
        
        // Cancel power card mode and refund the card
        function cancelPowerCard() {
            console.log('Canceling power card mode');
            
            // Send cancel event to server to refund the card
            socket.emit('cancel_power_card', { game_id: gameId });
            
            // Reset all power card modes
            swapMode = false;
            swapPositions = [];
            wildPlaceMode = false;
            landmineMode = false;
            blockMode = false;
            cardSwapMode = false;
            cardSwapStep = 'none';
            cardSwapOwnCards = [];
            cardSwapOpponent = null;
            cardSwapOpponentCards = [];
            
            // Clear visual hints
            document.getElementById('gameBoard').style.cursor = 'default';
            document.querySelectorAll('.cell').forEach(cell => {
                cell.style.outline = '';
            });
            
            // Hide cancel button
            document.getElementById('cancelPowerBtn').style.display = 'none';
            
            // Close any open modals
            const modal = document.getElementById('cardSwapModal');
            if (modal) modal.remove();
            
            showNotification('Power card canceled - card returned to hand', 'info');
        }
        
        // Show cancel button when entering power card mode
        function showCancelButton() {
            document.getElementById('cancelPowerBtn').style.display = 'block';
        }
        
        // Hide cancel button
        function hideCancelButton() {
            document.getElementById('cancelPowerBtn').style.display = 'none';
        }
        
        // Card Swap Modal Functions
        function showOpponentSelectModal(opponents) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.id = 'cardSwapModal';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: linear-gradient(135deg, #2d3436, #1a1a2e);
                padding: 30px;
                border-radius: 15px;
                border: 3px solid #FFD700;
                text-align: center;
                max-width: 400px;
            `;
            
            modal.innerHTML = `
                <h2 style="color: #FFD700; margin-bottom: 20px;">üîÑ Select Opponent</h2>
                <p style="color: white; margin-bottom: 20px;">Choose which player to swap cards with:</p>
                <div id="opponentButtons" style="display: flex; flex-direction: column; gap: 10px;"></div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            const buttonsDiv = modal.querySelector('#opponentButtons');
            opponents.forEach(opp => {
                const btn = document.createElement('button');
                btn.textContent = `${opp.name} (${opp.hand_size} cards)`;
                btn.style.cssText = `
                    padding: 15px 30px;
                    font-size: 1.1em;
                    background: linear-gradient(135deg, #4CAF50, #2196F3);
                    border: none;
                    border-radius: 8px;
                    color: white;
                    cursor: pointer;
                    transition: transform 0.2s;
                `;
                btn.onmouseover = () => btn.style.transform = 'scale(1.05)';
                btn.onmouseout = () => btn.style.transform = 'scale(1)';
                btn.onclick = () => {
                    cardSwapOpponent = opp.name;
                    overlay.remove();
                    // Send opponent selection to server
                    socket.emit('card_swap_action', {
                        game_id: gameId,
                        step: 'select_opponent',
                        opponent: opp.name
                    });
                };
                buttonsDiv.appendChild(btn);
            });
        }
        
        function showOpponentCardsModal(opponentName, handSize) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.id = 'cardSwapModal';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: linear-gradient(135deg, #2d3436, #1a1a2e);
                padding: 30px;
                border-radius: 15px;
                border: 3px solid #FFD700;
                text-align: center;
                max-width: 600px;
            `;
            
            modal.innerHTML = `
                <h2 style="color: #FFD700; margin-bottom: 20px;">üîÑ Select 2 Cards from ${opponentName}</h2>
                <p style="color: white; margin-bottom: 20px;">Click on 2 face-down cards to take:</p>
                <div id="opponentCardsGrid" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 20px;"></div>
                <p id="selectionCount" style="color: #FFD700;">Selected: 0/2</p>
                <button id="confirmSwapBtn" disabled style="
                    padding: 15px 30px;
                    font-size: 1.1em;
                    background: gray;
                    border: none;
                    border-radius: 8px;
                    color: white;
                    cursor: not-allowed;
                    margin-top: 10px;
                ">Confirm Swap</button>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            const cardsGrid = modal.querySelector('#opponentCardsGrid');
            const selectionCount = modal.querySelector('#selectionCount');
            const confirmBtn = modal.querySelector('#confirmSwapBtn');
            let selectedIndices = [];
            
            // Create face-down cards
            for (let i = 0; i < handSize; i++) {
                const card = document.createElement('div');
                card.style.cssText = `
                    width: 60px;
                    height: 90px;
                    background: linear-gradient(135deg, #1a1a2e, #2d3436);
                    border: 2px solid #666;
                    border-radius: 8px;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    cursor: pointer;
                    transition: all 0.2s;
                    font-size: 2em;
                `;
                card.textContent = '?';
                card.dataset.index = i;
                
                card.onclick = () => {
                    const idx = parseInt(card.dataset.index);
                    if (selectedIndices.includes(idx)) {
                        // Deselect
                        selectedIndices = selectedIndices.filter(x => x !== idx);
                        card.style.border = '2px solid #666';
                        card.style.boxShadow = 'none';
                    } else if (selectedIndices.length < 2) {
                        // Select
                        selectedIndices.push(idx);
                        card.style.border = '3px solid #FFD700';
                        card.style.boxShadow = '0 0 15px rgba(255,215,0,0.5)';
                    }
                    
                    selectionCount.textContent = `Selected: ${selectedIndices.length}/2`;
                    
                    if (selectedIndices.length === 2) {
                        confirmBtn.disabled = false;
                        confirmBtn.style.background = 'linear-gradient(135deg, #4CAF50, #2196F3)';
                        confirmBtn.style.cursor = 'pointer';
                    } else {
                        confirmBtn.disabled = true;
                        confirmBtn.style.background = 'gray';
                        confirmBtn.style.cursor = 'not-allowed';
                    }
                };
                
                cardsGrid.appendChild(card);
            }
            
            confirmBtn.onclick = () => {
                if (selectedIndices.length === 2) {
                    cardSwapOpponentCards = selectedIndices;
                    overlay.remove();
                    // Send opponent card selection to server
                    socket.emit('card_swap_action', {
                        game_id: gameId,
                        step: 'select_opponent_cards',
                        card_indices: selectedIndices
                    });
                    // Reset card swap state
                    cardSwapMode = false;
                    cardSwapStep = 'none';
                    hideCancelButton();
                }
            };
        }

        function showNotification(message, type = 'info') {
            // Create a temporary notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 15px 25px;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                ${type === 'warning' ? 'background: linear-gradient(135deg, #ff6b35, #ff3333);' : 'background: linear-gradient(135deg, #4CAF50, #2196F3);'}
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function toggleShareButton() {
            const gameIdInput = document.getElementById('gameId').value.trim();
            const shareBtn = document.getElementById('shareButton');
            if (gameIdInput) {
                shareBtn.disabled = false;
                shareBtn.style.opacity = '1';
                shareBtn.style.cursor = 'pointer';
            } else {
                shareBtn.disabled = true;
                shareBtn.style.opacity = '0.5';
                shareBtn.style.cursor = 'not-allowed';
            }
        }

        function shareGameRoom() {
            const gameIdValue = document.getElementById('gameId').value.trim();
            if (!gameIdValue) {
                alert('Please enter a Game ID first');
                return;
            }
            
            // Create shareable URL with game ID
            const shareUrl = `${window.location.origin}${window.location.pathname}?gameId=${encodeURIComponent(gameIdValue)}`;
            const shareText = `Join my Twenty Dots game!\n\nGame ID: ${gameIdValue}\n\nJoin here: ${shareUrl}\n\nJust enter the Game ID and your name to play!`;
            
            // Try to copy to clipboard
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareText).then(() => {
                    const btn = document.getElementById('shareButton');
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '‚úì Copied!';
                    btn.style.background = '#2196F3';
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.style.background = '#4CAF50';
                    }, 2000);
                }).catch(() => {
                    // Fallback: show alert with info
                    alert(shareText);
                });
            } else {
                // Fallback for older browsers
                alert(shareText);
            }
        }

        // Music Control Functions
        let audioErrorCount = 0;
        
        function initMusicPlaylist() {
            const audio = document.getElementById('bgMusic');
            // Shuffle playlist on init for variety
            shufflePlaylist();
            // Load first track
            audio.src = musicPlaylist[currentTrackIndex];
            audio.volume = 0.3;
            audio.crossOrigin = 'anonymous';
            
            // When track ends, play next one
            audio.addEventListener('ended', function() {
                audioErrorCount = 0; // Reset error count on successful play
                playNextTrack();
            });
            
            // Track successful load
            audio.addEventListener('canplaythrough', function() {
                console.log('Audio loaded successfully:', musicPlaylist[currentTrackIndex]);
                audioErrorCount = 0;
            });
            
            // Handle load errors - try next track
            audio.addEventListener('error', function(e) {
                console.log('Track failed to load:', musicPlaylist[currentTrackIndex], e);
                audioErrorCount++;
                if (audioErrorCount < musicPlaylist.length) {
                    currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
                    audio.src = musicPlaylist[currentTrackIndex];
                    if (musicPlaying) {
                        audio.play().catch(err => console.log('Retry failed:', err));
                    }
                } else {
                    showNotification('Unable to load music - check your connection', 'warning');
                }
            });
        }
        
        function shufflePlaylist() {
            // Fisher-Yates shuffle
            for (let i = musicPlaylist.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [musicPlaylist[i], musicPlaylist[j]] = [musicPlaylist[j], musicPlaylist[i]];
            }
        }
        
        function playNextTrack() {
            const audio = document.getElementById('bgMusic');
            currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
            audio.src = musicPlaylist[currentTrackIndex];
            if (musicPlaying) {
                audio.play().catch(err => {
                    console.log('Next track failed:', err);
                    // Try another track
                    setTimeout(() => playNextTrack(), 500);
                });
            }
        }
        
        function skipTrack() {
            if (!musicInitialized) {
                // Initialize first if not done
                initMusicPlaylist();
                musicInitialized = true;
            }
            playNextTrack();
            // Start playing if not already
            if (!musicPlaying) {
                const audio = document.getElementById('bgMusic');
                const btn = document.getElementById('musicToggle');
                audio.play().then(() => {
                    btn.textContent = 'üéµ';
                    btn.classList.add('playing');
                    musicPlaying = true;
                }).catch(err => {
                    console.log('Skip track failed:', err);
                });
            }
        }
        
        function toggleMusic() {
            const audio = document.getElementById('bgMusic');
            const btn = document.getElementById('musicToggle');
            
            if (!musicInitialized) {
                // First time - initialize playlist
                initMusicPlaylist();
                musicInitialized = true;
            }
            
            if (musicPlaying) {
                audio.pause();
                btn.textContent = 'üîá';
                btn.classList.remove('playing');
                musicPlaying = false;
            } else {
                audio.play().then(() => {
                    btn.textContent = 'üéµ';
                    btn.classList.add('playing');
                    musicPlaying = true;
                }).catch(err => {
                    console.log('Audio playback failed:', err);
                    showNotification('Click again to enable music', 'info');
                });
            }
        }
        
        // Try to resume music context on any user interaction (for mobile)
        document.addEventListener('click', function initAudioContext() {
            const audio = document.getElementById('bgMusic');
            if (audio && musicPlaying && audio.paused) {
                audio.play().catch(() => {});
            }
        }, { once: false });

        // Start by showing mode selection
        document.getElementById('modeScreen').style.display = 'flex';
    </script>
</body>
</html>
